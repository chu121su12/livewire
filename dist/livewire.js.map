{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap","webpack:///./src/js/dom/dom_element.js","webpack:///./src/js/action/event.js","webpack:///./src/js/store.js","webpack:///./src/js/util/debounce.js","webpack:///./src/js/util/walk.js","webpack:///./src/js/util/dispatch.js","webpack:///./src/js/util/add_mixin.js","webpack:///./src/js/util/index.js","webpack:///./src/js/action/index.js","webpack:///./src/js/node_initializer.js","webpack:///./src/js/action/method.js","webpack:///./src/js/dom/prefix.js","webpack:///./src/js/dom/directive_manager.js","webpack:///./src/js/dom/directive.js","webpack:///./src/js/action/model.js","webpack:///./src/js/connection/drivers/http.js","webpack:///./src/js/connection/drivers/index.js","webpack:///./src/js/connection/index.js","webpack:///./src/js/dom/morphdom/util.js","webpack:///./src/js/message.js","webpack:///./src/js/dom/morphdom/specialElHandlers.js","webpack:///./src/js/dom/morphdom/morphdom.js","webpack:///./src/js/dom/morphdom/index.js","webpack:///./src/js/dom/morphdom/morphAttrs.js","webpack:///./src/js/component/handle_loading_directives.js","webpack:///./src/js/component/index.js","webpack:///./src/js/index.js"],"names":["root","factory","exports","module","define","amd","a","i","window","installedModules","__webpack_require__","moduleId","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","prefix","require","DOMElement","el","_classCallCheck","this","directives","ElementDirectives","fn","_this","requestAnimationFrame","_this2","has","directive","modifiers","includes","style","opacity","transition","concat","durationOr","nextFrame","transitionName","classList","add","remove","duration","Number","getComputedStyle","transitionDuration","replace","setTimeout","onDiscarded","_this3","closestByAttribute","attribute","closest","hasAttribute","getAttribute","setAttribute","document","activeElement","fromEl","dirtyInputs","isInput","type","Array","from","isFocused","tagName","checked","multiple","getSelectValues","rawNode","isSameNode","_this$el","getAttributeNames","apply","arguments","_this$el2","addEventListener","_this$el3","querySelector","_this$el4","querySelectorAll","component","modelString","modelStringWithArraySyntaxForNumericKeys","match","num","modelValue","eval","innerHTML","updateSelect","options","filter","option","selected","map","text","arrayWrappedValue","forEach","allEls","slice","onlyChildEls","callback","cached","focus","_default","event","params","_possibleConstructorReturn","_getPrototypeOf","payload","Action","store","componentsById","addComponent","id","findComponent","wipeComponents","emit","_len","length","_key","componentsListeningForEvent","addAction","EventAction","keys","events","debounceWithFiringOnBothEnds","func","wait","timeout","timesInterupted","context","args","callNow","clearTimeout","debounce","immediate","walk","node","firstElementChild","nextElementSibling","dispatch","eventName","_ref","undefined","target","cancelable","data","createEvent","initEvent","preventDefaultSupported","preventDefault","defaultPrevented","dispatchEvent","addMixin","classTarget","sources","source","descriptors","reduce","getOwnPropertyDescriptor","getOwnPropertySymbols","sym","descriptor","defineProperties","kebabCase","subject","split","join","toLowerCase","tap","output","__webpack_exports__","ref","_util__WEBPACK_IMPORTED_MODULE_0__","_action_model__WEBPACK_IMPORTED_MODULE_1__","_action_method__WEBPACK_IMPORTED_MODULE_2__","_dom_element__WEBPACK_IMPORTED_MODULE_3__","_store__WEBPACK_IMPORTED_MODULE_4__","initialize","all","registerElementForLoading","fireActionOnInterval","setInputValueFromModel","attachModelListener","attachDomListener","refName","addLoadingEl","method","setInterval","MethodAction","isLive","debounceOrDont","e","model","valueFromInput","ModelAction","queueSyncInput","attachListener","preventAndStop","tempStoreForEval","group1","stopPropagation","content","extractTypeModifiersAndValue","values","RegExp","_name$replace$split2","_toArray","ElementDirective","rawName","defaultDuration","durationInMilliSeconds","durationInMilliSecondsString","find","mod","durationInSecondsString","rawMethod","methodAndParamString","param","parseOutMethodAndParams","drivers","http","onMessage","init","sendMessage","token","tokenTag","head","livewire_token","Error","fetch","body","JSON","stringify","credentials","headers","X-CSRF-TOKEN","Content-Type","Accept","then","response","ok","parse","showHtmlModal","html","page","createElement","modal","position","width","height","padding","backgroundColor","zIndex","iframe","borderRadius","appendChild","prepend","overflow","contentWindow","open","write","outerHTML","close","hideHtmlModal","Connection","driver","refresh","receiveMessage","message","prepareForSend","range","actionQueue","syncQueue","message_classCallCheck","loadingEls","setLoading","refs","children","dom","eventQueue","listeningFor","redirectTo","action","NS_XHTML","doc","testEl","hasAttributeNS","namespaceURI","getAttributeNode","compareNodeNames","toEl","fromNodeName","nodeName","toNodeName","actualize","charCodeAt","toUpperCase","syncBooleanAttrProp","removeAttribute","specialElHandlers","OPTION","INPUT","TEXTAREA","newValue","firstChild","oldValue","nodeValue","placeholder","SELECT","curChild","nextSibling","selectedIndex","ELEMENT_NODE","TEXT_NODE","COMMENT_NODE","noop","defaultGetNodeKey","callHook","hook","morphAttrs","morphdom","fromNode","toNode","attr","attrName","attrNamespaceURI","attrValue","attrs","attributes","localName","getAttributeNS","setAttributeNS","specified","removeAttributeNS","toNodeHtml","str","createRange","selectNode","createContextualFragment","fragment","childNodes","keyedRemovalList","getNodeKey","onBeforeNodeAdded","onNodeAdded","onBeforeElUpdated","onElUpdated","onBeforeNodeDiscarded","onNodeDiscarded","onBeforeElChildrenUpdated","childrenOnly","fromNodesLookup","addKeyedRemoval","push","removeNode","parentNode","skipKeyedNodes","removeChild","walkDiscardedChildNodes","nodeType","handleNodeAdded","unmatchedFromEl","replaceChild","morphEl","curFromNodeKey","toElKey","isEqualNode","curToNodeKey","fromNextSibling","toNextSibling","matchingFromEl","curToNodeChild","curFromNodeChild","outer","curFromNodeType","isCompatible","insertBefore","onBeforeNodeAddedResult","ownerDocument","specialElHandler","indexTree","morphedNode","morphedNodeType","toNodeType","nextChild","moveChildren","createElementNS","len","elToRemove","handle_loading_directives","loadingElsByRef","targetRef","removeLoadingEl","refEls","flat","unsetLoading","Component","connection","component_classCallCheck","messageInTransit","nodeInitializer","fireMessage","Message","clearSyncQueue","clearActionQueue","storeResponse","location","href","replaceDom","handleDirtyInputs","_toConsumableArray","missing","rawDom","preserveActiveElement","handleMorph","addValueAttributesToModelNodes","trim","inputDom","_this4","tempDom","allModelElementsInside","_this5","transitionElementIn","transitionElementOut","nodeDiscarded","isComponentRootEl","to","preserveValueAttributeIfNotDirty","closestComponentId","closestRoot","_this6","callbackWhenNewComponentIsEncountered","getByAttributeAndValue","handleLoadingDirectives","Livewire","js_classCallCheck","_typeof","components","start","_this$components","stop","rootComponentElementsWithNoParents"],"mappings":"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","file":"/dist/livewire.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n","import ElementDirectives from \"./directive_manager\";\nconst prefix = require('./prefix.js')()\n\n/**\n * This is intended to isolate all native DOM operations. The operations that happen\n * one specific element will be instance methods, the operations you would normally\n * perform on the \"document\" (like \"document.querySelector\") will be static methods.\n * Consider this a decorator for the ElementNode JavaScript object. (Hence the\n * method forwarding I have to do at the bottom)\n */\nexport default class DOMElement {\n    constructor(el) {\n        this.el = el\n        this.directives = new ElementDirectives(el)\n    }\n\n    nextFrame(fn) {\n        requestAnimationFrame(() => {\n            requestAnimationFrame(fn.bind(this));\n        });\n    }\n\n    static rootComponentElements() {\n        return Array.from(document.querySelectorAll(`[${prefix}\\\\:id]`))\n            .map(el => new DOMElement(el))\n    }\n\n    static rootComponentElementsWithNoParents() {\n        // In CSS, it's simple to select all elements that DO have a certain ancestor.\n        // However, it's not simple (kinda impossible) to select elements that DONT have\n        // a certain ancestor. Therefore, we will flip the logic: select all roots that DO have\n        // have a root ancestor, then select all roots that DONT, then diff the two.\n\n        // Convert NodeLists to Arrays so we can use \".includes()\". Ew.\n        const allEls = Array.prototype.slice.call(\n            document.querySelectorAll(`[${prefix}\\\\:id]`)\n        )\n        const onlyChildEls = Array.prototype.slice.call(\n            document.querySelectorAll(`[${prefix}\\\\:id] [${prefix}\\\\:id]`)\n        )\n\n        return allEls\n            .filter(el => ! onlyChildEls.includes(el))\n            .map(el => new DOMElement(el))\n    }\n\n    static allModelElementsInside(root) {\n        return Array.from(\n            root.querySelectorAll(`[${prefix}\\\\:model]`)\n        ).map(el => new DOMElement(el))\n    }\n\n    static getByAttributeAndValue(attribute, value) {\n        return new DOMElement(document.querySelector(`[${prefix}\\\\:${attribute}=\"${value}\"]`))\n    }\n\n    static preserveActiveElement(callback) {\n        const cached = document.activeElement\n\n        callback()\n\n        cached.focus()\n    }\n\n    rawNode() {\n        return this.el\n    }\n\n    transitionElementIn() {\n        if (! this.directives.has('transition')) return\n        const directive = this.directives.get('transition')\n\n        // If \".out\" modifier is passed, don't fade in.\n        if (directive.modifiers.includes('out') && ! directive.modifiers.includes('in')) {\n            return true\n        }\n\n        if (directive.modifiers.includes('fade')) {\n            this.el.style.opacity = 0\n            this.el.style.transition = `opacity ${directive.durationOr(300) / 1000}s ease`\n\n            this.nextFrame(() => {\n                this.el.style.opacity = 1\n            })\n\n            return\n        }\n\n        const transitionName = directive.value\n\n        this.el.classList.add(`${transitionName}-enter`)\n        this.el.classList.add(`${transitionName}-enter-active`)\n\n        this.nextFrame(() => {\n            this.el.classList.remove(`${transitionName}-enter`)\n\n            const duration = Number(getComputedStyle(this.el).transitionDuration.replace('s', '')) * 1000\n\n            setTimeout(() => {\n                this.el.classList.remove(`${transitionName}-enter-active`)\n            }, duration)\n        })\n    }\n\n    transitionElementOut(onDiscarded) {\n        if (!this.directives.has('transition')) return true\n        const directive = this.directives.get('transition')\n\n        // If \".in\" modifier is passed, don't fade out.\n        if (directive.modifiers.includes('in') && ! directive.modifiers.includes('out')) {\n            return true\n        }\n\n        if (directive.modifiers.includes('fade')) {\n            this.nextFrame(() => {\n                this.el.style.opacity = 0\n\n                setTimeout(() => {\n                    onDiscarded(this.el)\n\n                    this.el.remove()\n                }, directive.durationOr(300));\n            })\n\n            return false\n        }\n\n        const transitionName = directive.value\n\n        this.el.classList.add(`${transitionName}-leave-active`)\n\n        this.nextFrame(() => {\n            this.el.classList.add(`${transitionName}-leave`)\n\n            const duration = Number(getComputedStyle(this.el).transitionDuration.replace('s', '')) * 1000\n\n            setTimeout(() => {\n                onDiscarded(this.el)\n\n                this.el.remove()\n            }, duration)\n        })\n\n        return false\n    }\n\n    closestRoot() {\n        return this.closestByAttribute('id')\n    }\n\n    closestByAttribute(attribute) {\n        return new DOMElement(this.el.closest(`[${prefix}\\\\:${attribute}]`))\n    }\n\n    isComponentRootEl() {\n        return this.hasAttribute('id')\n    }\n\n    hasAttribute(attribute) {\n        return this.el.hasAttribute(`${prefix}:${attribute}`)\n    }\n\n    getAttribute(attribute) {\n        return this.el.getAttribute(`${prefix}:${attribute}`)\n    }\n\n    setAttribute(attribute, value) {\n        return this.el.setAttribute(`${prefix}:${attribute}`, value)\n    }\n\n    isFocused() {\n        return this.el === document.activeElement\n    }\n\n    preserveValueAttributeIfNotDirty(fromEl, dirtyInputs) {\n        const isInput = this.isInput() && fromEl.isInput()\n\n        if (isInput) {\n            if (this.el.type === 'submit') {\n                return\n            }\n\n            if (this.directives.has('model')) {\n                // If the model is not inside \"dirtyInputs\" && the input element is focused.\n                if (\n                    ! Array.from(dirtyInputs).includes(this.directives.get('model').value)\n                    && fromEl.isFocused()\n                ) {\n                    // Transfer the current \"fromEl\" value (preserving / overriding it).\n                    this.el.value = fromEl.el.value\n                }\n            }\n        }\n    }\n\n    isInput() {\n        return this.el.tagName === 'INPUT'\n            || this.el.tagName === 'TEXTAREA'\n            || this.el.tagName === 'SELECT'\n    }\n\n    valueFromInput() {\n        if (this.el.type === 'checkbox') {\n            return this.el.checked\n        } else if (this.el.tagName === 'SELECT' && this.el.multiple) {\n            return this.getSelectValues()\n        }\n\n        return this.el.value\n    }\n\n    get ref() {\n        return this.directives.get('ref')\n            ? this.directives.get('ref').value\n            : null\n    }\n\n    isSameNode(el) {\n        // We need to drop down to the raw node if we are comparing\n        // to another \"DOMElement\" Instance.\n        if (typeof el.rawNode === 'function') {\n            return this.el.isSameNode(el.rawNode())\n        }\n\n        return this.el.isSameNode(el)\n    }\n\n    getAttributeNames() {\n        return this.el.getAttributeNames(...arguments)\n    }\n\n    addEventListener() {\n        return this.el.addEventListener(...arguments)\n    }\n\n    get classList() {\n        return this.el.classList\n    }\n\n    querySelector() {\n        return this.el.querySelector(...arguments)\n    }\n\n    querySelectorAll() {\n        return this.el.querySelectorAll(...arguments)\n    }\n\n    setInputValueFromModel(component) {\n        const modelString = this.directives.get('model').value\n        const modelStringWithArraySyntaxForNumericKeys = modelString.replace(/\\.([0-9]+)/, (match, num) => { return `[${num}]` })\n        const modelValue = eval('component.data.'+modelStringWithArraySyntaxForNumericKeys)\n\n        if (! modelValue) return\n\n        // <textarea>'s don't use value properties, so we have to treat them differently.\n        if (this.el.tagName === 'TEXTAREA') {\n            this.el.innerHTML = modelValue\n        } else if (this.el.type === 'checkbox') {\n            this.el.checked = modelValue\n        } else if (this.el.tagName === 'SELECT') {\n            this.updateSelect(modelValue)\n        } else if (! this.el.hasAttribute('value')) {\n            this.el.setAttribute('value', modelValue)\n        }\n    }\n\n    getSelectValues() {\n        return Array.from(this.el.options)\n            .filter(option => option.selected)\n            .map(option => { return option.value || option.text})\n    }\n\n    updateSelect(value) {\n        const arrayWrappedValue = [].concat(value)\n        Array.from(this.el.options).forEach(option => {\n            option.selected = arrayWrappedValue.includes(option.value)\n        })\n    }\n}\n","import Action from '.'\n\nexport default class extends Action {\n    constructor(event, params, el) {\n        super(el)\n\n        this.type = 'fireEvent'\n        this.payload = {\n            event,\n            params,\n        }\n    }\n}\n","import EventAction from \"./action/event\";\n\nconst store = {\n    componentsById: {},\n\n    addComponent(component) {\n        return this.componentsById[component.id] = component\n    },\n\n    findComponent(id) {\n        return this.componentsById[id]\n    },\n\n    wipeComponents() {\n        this.componentsById = {}\n    },\n\n    emit(event, ...params) {\n        this.componentsListeningForEvent(event).forEach(\n            component => component.addAction(new EventAction(\n                event, params\n            ))\n        )\n    },\n\n    componentsListeningForEvent(event) {\n        return Object.keys(this.componentsById).map(key => {\n            return this.componentsById[key]\n        }).filter(component => {\n            return component.events.includes(event)\n        })\n    },\n}\n\nexport default store\n","// This is kindof like a normal debouncer, except it behaves like both \"immediate\" and\n// \"non-immediate\" strategies. I'll try to visually demonstrate the differences:\n// [normal] =    .......|\n// [immediate] = |.......\n// [both] =      |......|\n\n// The reason I want it to fire on both ends of the debounce is for the following scenario:\n// - a user types a letter into an input\n// - the debouncer is waiting 200ms to send the ajax request\n// - in the meantime a user hits the enter key\n// - the debouncer is not up yet, so the \"enter\" request will get fired before the \"key\" request\n\n// Note: I also added a checker in here (\"wasInterupted\") for the the case of a user\n// only typing one key, but two ajax requests getting sent.\n\nexport function debounceWithFiringOnBothEnds(func, wait) {\n    var timeout;\n    var timesInterupted = 0;\n\n\treturn function() {\n        var context = this, args = arguments;\n\n        var callNow = ! timeout;\n\n        if (timeout) {\n            clearTimeout(timeout);\n            timesInterupted++\n        }\n\n        timeout = setTimeout(function () {\n            timeout = null;\n            if (timesInterupted > 0) {\n                func.apply(context, args);\n                timesInterupted = 0\n            }\n        }, wait);\n\n\t\tif (callNow) {\n            func.apply(context, args);\n        }\n\t};\n};\n\nexport function debounce(func, wait, immediate) {\n    var timeout\n    return function () {\n        var context = this, args = arguments\n        var later = function () {\n            timeout = null\n            if (!immediate) func.apply(context, args)\n        }\n        var callNow = immediate && !timeout\n        clearTimeout(timeout)\n        timeout = setTimeout(later, wait)\n        if (callNow) func.apply(context, args)\n    }\n}\n","\n// A little DOM-tree walker.\n// (TreeWalker won't do because I need to conditionaly ignore sub-trees using the callback)\nexport function walk(root, callback) {\n    if (callback(root) === false) return\n\n    let node = root.firstElementChild\n\n    while (node) {\n        walk(node, callback)\n        node = node.nextElementSibling\n    }\n}\n","// I grabbed this from Turbolink's codebase.\nexport function dispatch(eventName, { target, cancelable, data } = {}) {\n    const event = document.createEvent(\"Events\")\n    event.initEvent(eventName, true, cancelable == true)\n    event.data = data || {}\n\n    // Fix setting `defaultPrevented` when `preventDefault()` is called\n    // http://stackoverflow.com/questions/23349191/event-preventdefault-is-not-working-in-ie-11-for-custom-events\n    if (event.cancelable && ! preventDefaultSupported) {\n        const { preventDefault } = event\n        event.preventDefault = function () {\n            if (! this.defaultPrevented) {\n                Object.defineProperty(this, \"defaultPrevented\", { get: () => true })\n            }\n            preventDefault.call(this)\n        }\n    }\n\n    (target || document).dispatchEvent(event)\n    return event\n}\n\nconst preventDefaultSupported = (() => {\n    const event = document.createEvent(\"Events\")\n    event.initEvent(\"test\", true, true)\n    event.preventDefault()\n    return event.defaultPrevented\n})()\n","\nexport function addMixin(classTarget, ...sources) {\n    sources.forEach(source => {\n        let descriptors = Object.keys(source).reduce((descriptors, key) => {\n            descriptors[key] = Object.getOwnPropertyDescriptor(source, key);\n            return descriptors;\n        }, {});\n\n        Object.getOwnPropertySymbols(source).forEach(sym => {\n            let descriptor = Object.getOwnPropertyDescriptor(source, sym);\n            if (descriptor.enumerable) {\n                descriptors[sym] = descriptor;\n            }\n        });\n        Object.defineProperties(classTarget.prototype, descriptors);\n    });\n    return classTarget.prototype;\n}\n","\nexport * from './debounce'\nexport * from './walk'\nexport * from './dispatch'\nexport * from './add_mixin'\n\nexport function kebabCase(subject) {\n    return subject.split(/[_\\s]/).join(\"-\").toLowerCase()\n}\n\nexport function tap(output, callback) {\n    callback(output)\n\n    return output\n}\n","\nexport default class {\n    constructor(el) {\n        this.el = el\n    }\n\n    get ref() {\n        return this.el ? this.el.ref : null\n    }\n}\n","import { debounceWithFiringOnBothEnds, kebabCase } from './util'\nimport ModelAction from './action/model'\nimport MethodAction from './action/method'\nimport DOMElement from './dom/dom_element'\nimport store from './store'\n\nexport default {\n    initialize(el, component) {\n        // Parse out \"direcives\", \"modifiers\", and \"value\" from livewire attributes.\n        el.directives.all().forEach(directive => {\n            switch (directive.type) {\n                case 'loading-class':\n                    this.registerElementForLoading(el, directive, component)\n                    break;\n\n                case 'poll':\n                    this.fireActionOnInterval(el, directive, component)\n                    break;\n\n                case 'model':\n                    el.setInputValueFromModel(component)\n                    this.attachModelListener(el, directive, component)\n                    break;\n\n                default:\n                    this.attachDomListener(el, directive, component)\n                    break;\n            }\n        })\n    },\n\n    registerElementForLoading(el, directive, component) {\n        const refName = el.directives.get('loading-target')\n            && el.directives.get('loading-target').value\n\n        component.addLoadingEl(\n            el,\n            directive.value,\n            refName,\n            directive.modifiers.includes('remove')\n        )\n    },\n\n    fireActionOnInterval(el, directive, component) {\n        const method = directive.method || '$refresh'\n\n        setInterval(() => {\n            component.addAction(new MethodAction(method, directive.params, el))\n        }, directive.durationOr(500));\n    },\n\n    attachModelListener(el, directive, component) {\n        const isLive = ! directive.modifiers.includes('lazy')\n        const debounceOrDont = isLive ? debounceWithFiringOnBothEnds : fn => fn\n\n        el.addEventListener('input', debounceOrDont(e => {\n            const model = directive.value\n            const el = new DOMElement(e.target)\n            const value = el.valueFromInput()\n\n            if (isLive) {\n                component.addAction(new ModelAction(model, value, el))\n            } else {\n                component.queueSyncInput(model, value)\n            }\n        }, 150))\n    },\n\n    attachDomListener(el, directive, component) {\n        switch (directive.type) {\n            case 'keydown':\n                this.attachListener(el, directive, component, (e) => {\n                    // Only handle listener if no, or matching key modifiers are passed.\n                    return ! (directive.modifiers.length === 0\n                        || directive.modifiers.includes(kebabCase(e.key)))\n                })\n                break;\n            default:\n                this.attachListener(el, directive, component)\n                break;\n        }\n    },\n\n    attachListener(el, directive, component, callback) {\n        el.addEventListener(directive.type, (e => {\n            if (callback && callback(e) !== false) {\n                return\n            }\n\n            const el = new DOMElement(e.target)\n\n            // This is outside the conditional below so \"wire:click.prevent\" without\n            // a value still prevents default.\n            this.preventAndStop(e, directive.modifiers)\n\n            // Check for global event emission.\n            if (directive.value.match(/\\$emit\\(.*\\)/)) {\n                const tempStoreForEval = store\n                eval(directive.value.replace(/\\$emit\\((.*)\\)/, (match, group1) => {\n                    return 'tempStoreForEval.emit('+group1+')'\n                }))\n                return\n            }\n\n            if (directive.value) {\n                component.addAction(new MethodAction(directive.method, directive.params, el))\n            }\n        }))\n    },\n\n    preventAndStop(event, modifiers) {\n        modifiers.includes('prevent') && event.preventDefault()\n\n        modifiers.includes('stop') && event.stopPropagation()\n    },\n}\n","import Action from '.'\n\nexport default class extends Action {\n    constructor(method, params, el) {\n        super(el)\n\n        this.type = 'callMethod'\n        this.payload = {\n            method,\n            params,\n        }\n    }\n}\n","var prefix = null;\n\nmodule.exports = function () {\n    if (prefix === null) {\n        prefix = (\n            document.querySelector('meta[name=\"livewire-prefix\"]')\n            || { content: 'wire' }\n        ).content\n    }\n\n    return prefix\n}\n","import ElementDirective from './directive';\n\nconst prefix = require('./prefix.js')()\n\nexport default class {\n    constructor(el) {\n        this.el = el\n        this.directives = this.extractTypeModifiersAndValue()\n    }\n\n    all() {\n        return Object.values(this.directives)\n    }\n\n    has(type) {\n        return Object.keys(this.directives).includes(type)\n    }\n\n    missing(type) {\n        return ! Object.keys(this.directives).includes(type)\n    }\n\n    get(type) {\n        return this.directives[type]\n    }\n\n    extractTypeModifiersAndValue() {\n        let directives = {}\n\n        this.el.getAttributeNames()\n            // Filter only the livewire directives.\n            .filter(name => name.match(new RegExp(prefix + ':')))\n            // Parse out the type, modifiers, and value from it.\n            .forEach(name => {\n                const [type, ...modifiers] = name.replace(new RegExp(prefix + ':'), '').split('.')\n\n                directives[type] = new ElementDirective(type, modifiers, name, this.el)\n            })\n\n        return directives\n    }\n}\n","\nexport default class {\n    constructor(type, modifiers, rawName, el) {\n        this.type = type\n        this.modifiers = modifiers\n        this.rawName = rawName\n        this.el = el\n    }\n\n    get value() {\n        return this.el.getAttribute(this.rawName)\n    }\n\n    get method() {\n        const { method } =  this.parseOutMethodAndParams(this.value)\n\n        return method\n    }\n\n    get params() {\n        const { params } =  this.parseOutMethodAndParams(this.value)\n\n        return params\n    }\n\n    durationOr(defaultDuration) {\n        let durationInMilliSeconds\n        const durationInMilliSecondsString = this.modifiers.find(mod => mod.match(/(.*)ms/))\n        const durationInSecondsString = this.modifiers.find(mod => mod.match(/(.*)s/))\n\n        if (durationInMilliSecondsString) {\n            durationInMilliSeconds = Number(durationInMilliSecondsString.replace('ms', ''))\n        } else if (durationInSecondsString){\n            durationInMilliSeconds = Number(durationInSecondsString.replace('s', '')) * 1000\n        }\n\n        return durationInMilliSeconds || defaultDuration\n    }\n\n    parseOutMethodAndParams(rawMethod) {\n        let method = rawMethod\n        let params = []\n        const methodAndParamString = method.match(/(.*)\\((.*)\\)/)\n\n        if (methodAndParamString) {\n            method = methodAndParamString[1]\n            params = methodAndParamString[2].split(', ').map(param => eval(param))\n        }\n\n        return { method, params }\n    }\n}\n","import Action from '.'\n\nexport default class extends Action {\n    constructor(name, value, el) {\n        super(el)\n\n        this.type = 'syncInput'\n        this.payload = {\n            name,\n            value,\n        }\n    }\n}\n","export default {\n    onMessage: null,\n\n    init() {\n        //\n    },\n\n    sendMessage(payload) {\n         const tokenTag = document.head.querySelector('meta[name=\"csrf-token\"]')\n         let token\n\n        if (! tokenTag) {\n            if (! window.livewire_token) {\n                throw new Error('Whoops, looks like you haven\\'t added a \"csrf-token\" meta tag');\n            }\n\n            token = window.livewire_token\n        } else {\n            token = tokenTag.content\n        }\n\n        fetch('/livewire/message', {\n            method: 'POST',\n            body: JSON.stringify(payload),\n            // This enables \"cookies\".\n            credentials: \"same-origin\",\n            headers: {\n                'X-CSRF-TOKEN': token,\n                'Content-Type': 'application/json',\n                'Accept': 'text/html, application/xhtml+xml',\n            },\n        }).then(response => {\n            if (response.ok) {\n                response.text().then(response => {\n                    this.onMessage.call(this, JSON.parse(response))\n                })\n            } else {\n                response.text().then(response => {\n                    this.showHtmlModal(response)\n                })\n            }\n        })\n    },\n\n    // This code and concept is all Jonathan Reinink - thanks main!\n    showHtmlModal(html) {\n        let page = document.createElement('html')\n        page.innerHTML = html\n        page.querySelectorAll('a').forEach(a => a.setAttribute('target', '_top'))\n\n        let modal = document.createElement('div')\n        modal.id = 'burst-error'\n        modal.style.position = 'fixed'\n        modal.style.width = '100vw'\n        modal.style.height = '100vh'\n        modal.style.padding = '50px'\n        modal.style.backgroundColor = 'rgba(0, 0, 0, .6)'\n        modal.style.zIndex = 200000\n\n        let iframe = document.createElement('iframe')\n        iframe.style.backgroundColor = 'white'\n        iframe.style.borderRadius = '5px'\n        iframe.style.width = '100%'\n        iframe.style.height = '100%'\n        modal.appendChild(iframe)\n\n        document.body.prepend(modal)\n        document.body.style.overflow = 'hidden'\n        iframe.contentWindow.document.open()\n        iframe.contentWindow.document.write(page.outerHTML)\n        iframe.contentWindow.document.close()\n\n        // Close on click.\n        modal.addEventListener('click', () => this.hideHtmlModal(modal))\n\n        // Close on escape key press.\n        modal.setAttribute('tabindex', 0)\n        modal.addEventListener('keydown', (e) => { if (e.key === 'Escape') this.hideHtmlModal(modal) })\n        modal.focus()\n    },\n\n    hideHtmlModal(modal) {\n        modal.outerHTML = ''\n        document.body.style.overflow = 'visible'\n    }\n}\n","import http from './http'\n\nexport default { http }\n","import { dispatch } from '../util'\nimport store from '../store';\n\nexport default class Connection {\n    constructor(driver) {\n        this.driver = driver\n\n        this.driver.onMessage = (payload) => {\n            this.onMessage(payload)\n        }\n\n        this.driver.refresh = (payload) => {\n            this.refresh()\n        }\n\n        this.driver.init()\n    }\n\n    onMessage(payload) {\n        store.findComponent(payload.id).receiveMessage(payload)\n\n        dispatch('livewire:update')\n    }\n\n    sendMessage(message) {\n        message.prepareForSend()\n\n        this.driver.sendMessage(message.payload());\n    }\n}\n","var range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nexport var doc = typeof document === 'undefined' ? undefined : document;\n\nvar testEl = doc ?\n    doc.body || doc.createElement('div') :\n    {};\n\n// Fixes <https://github.com/patrick-steele-idem/morphdom/issues/32>\n// (IE7+ support) <=IE7 does not support el.hasAttribute(name)\nvar actualHasAttributeNS;\n\nif (testEl.hasAttributeNS) {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.hasAttributeNS(namespaceURI, name);\n    };\n} else if (testEl.hasAttribute) {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.hasAttribute(name);\n    };\n} else {\n    actualHasAttributeNS = function(el, namespaceURI, name) {\n        return el.getAttributeNode(namespaceURI, name) != null;\n    };\n}\n\nexport var hasAttributeNS = actualHasAttributeNS;\n\n\nexport function toElement(str) {\n    if (!range && doc.createRange) {\n        range = doc.createRange();\n        range.selectNode(doc.body);\n    }\n\n    var fragment;\n    if (range && range.createContextualFragment) {\n        fragment = range.createContextualFragment(str);\n    } else {\n        fragment = doc.createElement('body');\n        fragment.innerHTML = str;\n    }\n    return fragment.childNodes[0];\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nexport function compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    if (toEl.actualize &&\n        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */\n        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {\n        // If the target element is a virtual DOM node then we may need to normalize the tag name\n        // before comparing. Normal HTML elements that are in the \"http://www.w3.org/1999/xhtml\"\n        // are converted to upper case\n        return fromNodeName === toNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nexport function createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nexport function moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n","\nexport default class {\n    constructor(component, actionQueue, syncQueue) {\n        this.component = component\n        this.actionQueue = actionQueue\n        this.syncQueue = syncQueue\n    }\n\n    prepareForSend() {\n        this.loadingEls = this.component.setLoading(this.refs)\n    }\n\n    get refs() {\n        return this.actionQueue\n            .map(action => {\n                return action.ref\n            })\n            .filter(ref => ref)\n    }\n\n    payload() {\n        return {\n            id: this.component.id,\n            data: this.component.data,\n            name: this.component.name,\n            children: this.component.children,\n            syncQueue: this.syncQueue,\n            actionQueue: this.actionQueue,\n        }\n    }\n\n    storeResponse(payload) {\n        return this.response = {\n            id: payload.id,\n            dom: payload.dom,\n            children: payload.children,\n            dirtyInputs: payload.dirtyInputs,\n            eventQueue: payload.eventQueue,\n            listeningFor: payload.listeningFor,\n            data: payload.data,\n            redirectTo: payload.redirectTo,\n        }\n    }\n}\n","import { hasAttributeNS } from './util';\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nexport default {\n    /**\n     * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n     * attribute when reading over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!hasAttributeNS(toEl, null, 'value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!hasAttributeNS(toEl, null, 'multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            var curChild = toEl.firstChild;\n            while(curChild) {\n                var nodeName = curChild.nodeName;\n                if (nodeName && nodeName.toUpperCase() === 'OPTION') {\n                    if (hasAttributeNS(curChild, null, 'selected')) {\n                        selectedIndex = i;\n                        break;\n                    }\n                    i++;\n                }\n                curChild = curChild.nextSibling;\n            }\n\n            fromEl.selectedIndex = i;\n        }\n    }\n};\n","// From Caleb: I had to change all the \"isSameNode\"s to \"isEqualNode\"s and now everything is working great!\n/**\n * I pulled in my own version of morphdom, so I could tweak it as needed.\n * Here are the tweaks I've made so far:\n *\n * 1) Changed all the \"isSameNode\"s to \"isEqualNode\"s so that morhing doesn't check by reference, only by equality.\n * 2) Automatically filter out any non-\"ElementNode\"s from the lifecycle hooks.\n */\n\n'use strict';\n\nimport { compareNodeNames, toElement, moveChildren, createElementNS, doc } from './util';\nimport specialElHandlers from './specialElHandlers';\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction callHook(hook, ...params) {\n    // Don't call hook on non-\"DOMElement\" elements.\n    if (typeof params[0].hasAttribute !== 'function') return\n\n    return hook(...params)\n}\n\nexport default function morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = {};\n        var keyedRemovalList;\n\n        function addKeyedRemoval(key) {\n            if (keyedRemovalList) {\n                keyedRemovalList.push(key);\n            } else {\n                keyedRemovalList = [key];\n            }\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = callHook(getNodeKey, curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        callHook(onNodeDiscarded, curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (callHook(onBeforeNodeDiscarded, node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            callHook(onNodeDiscarded, node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = callHook(getNodeKey, el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = callHook(getNodeKey, el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = callHook(getNodeKey, curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            callHook(onNodeAdded, el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = callHook(getNodeKey, curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphEl(unmatchedFromEl, curChild);\n                    }\n                }\n\n                handleNodeAdded(curChild);\n                curChild = nextSibling;\n            }\n        }\n\n        function morphEl(fromEl, toEl, childrenOnly) {\n            var toElKey = callHook(getNodeKey, toEl);\n            var curFromNodeKey;\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it is will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (toNode.isEqualNode && toNode.isEqualNode(fromNode)) {\n                return;\n            }\n\n            if (!childrenOnly) {\n                if (callHook(onBeforeElUpdated, fromEl, toEl) === false) {\n                    return;\n                }\n\n                morphAttrs(fromEl, toEl);\n                callHook(onElUpdated, fromEl);\n\n                if (callHook(onBeforeElChildrenUpdated, fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n                var curToNodeChild = toEl.firstChild;\n                var curFromNodeChild = fromEl.firstChild;\n                var curToNodeKey;\n\n                var fromNextSibling;\n                var toNextSibling;\n                var matchingFromEl;\n\n                outer: while (curToNodeChild) {\n                    toNextSibling = curToNodeChild.nextSibling;\n                    curToNodeKey = callHook(getNodeKey, curToNodeChild);\n\n                    while (curFromNodeChild) {\n                        fromNextSibling = curFromNodeChild.nextSibling;\n\n                        if (curToNodeChild.isEqualNode && curToNodeChild.isEqualNode(curFromNodeChild)) {\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        curFromNodeKey = callHook(getNodeKey, curFromNodeChild);\n\n                        var curFromNodeType = curFromNodeChild.nodeType;\n\n                        var isCompatible = undefined;\n\n                        if (curFromNodeType === curToNodeChild.nodeType) {\n                            if (curFromNodeType === ELEMENT_NODE) {\n                                // Both nodes being compared are Element nodes\n\n                                if (curToNodeKey) {\n                                    // The target node has a key so we want to match it up with the correct element\n                                    // in the original DOM tree\n                                    if (curToNodeKey !== curFromNodeKey) {\n                                        // The current element in the original DOM tree does not have a matching key so\n                                        // let's check our lookup to see if there is a matching element in the original\n                                        // DOM tree\n                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                            if (curFromNodeChild.nextSibling === matchingFromEl) {\n                                                // Special case for single element removals. To avoid removing the original\n                                                // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                                // we will instead discard the current node and wait until the next\n                                                // iteration to properly match up the keyed target element with its matching\n                                                // element in the original tree\n                                                isCompatible = false;\n                                            } else {\n                                                // We found a matching keyed element somewhere in the original DOM tree.\n                                                // Let's moving the original DOM node into the current position and morph\n                                                // it.\n\n                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                                // the `removeNode()` function for the node that is being discarded so that\n                                                // all lifecycle hooks are correctly invoked\n                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                                fromNextSibling = curFromNodeChild.nextSibling;\n\n                                                if (curFromNodeKey) {\n                                                    // Since the node is keyed it might be matched up later so we defer\n                                                    // the actual removal to later\n                                                    addKeyedRemoval(curFromNodeKey);\n                                                } else {\n                                                    // NOTE: we skip nested keyed nodes from being removed since there is\n                                                    //       still a chance they will be matched up later\n                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                                }\n\n                                                curFromNodeChild = matchingFromEl;\n                                            }\n                                        } else {\n                                            // The nodes are not compatible since the \"to\" node has a key and there\n                                            // is no matching keyed node in the source tree\n                                            isCompatible = false;\n                                        }\n                                    }\n                                } else if (curFromNodeKey) {\n                                    // The original has a key\n                                    isCompatible = false;\n                                }\n\n                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                                if (isCompatible) {\n                                    // We found compatible DOM elements so transform\n                                    // the current \"from\" node to match the current\n                                    // target DOM node.\n                                    morphEl(curFromNodeChild, curToNodeChild);\n                                }\n\n                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                                // Both nodes being compared are Text or Comment nodes\n                                isCompatible = true;\n                                // Simply update nodeValue on the original node to\n                                // change the text value\n                                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                                }\n\n                            }\n                        }\n\n                        if (isCompatible) {\n                            // Advance both the \"to\" child and the \"from\" child since we found a match\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        // No compatible match so remove the old node from the DOM and continue trying to find a\n                        // match in the original DOM. However, we only do this if the from node is not keyed\n                        // since it is possible that a keyed node might match up with a node somewhere else in the\n                        // target tree and we don't want to discard it just yet since it still might find a\n                        // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                        // that didn't find a home\n                        if (curFromNodeKey) {\n                            // Since the node is keyed it might be matched up later so we defer\n                            // the actual removal to later\n                            addKeyedRemoval(curFromNodeKey);\n                        } else {\n                            // NOTE: we skip nested keyed nodes from being removed since there is\n                            //       still a chance they will be matched up later\n                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                        }\n\n                        curFromNodeChild = fromNextSibling;\n                    }\n\n                    // If we got this far then we did not find a candidate match for\n                    // our \"to node\" and we exhausted all of the children \"from\"\n                    // nodes. Therefore, we will just append the current \"to\" node\n                    // to the end\n                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                        fromEl.appendChild(matchingFromEl);\n                        morphEl(matchingFromEl, curToNodeChild);\n                    } else {\n                        var onBeforeNodeAddedResult = callHook(onBeforeNodeAdded, curToNodeChild);\n                        if (onBeforeNodeAddedResult !== false) {\n                            if (onBeforeNodeAddedResult) {\n                                curToNodeChild = onBeforeNodeAddedResult;\n                            }\n\n                            if (curToNodeChild.actualize) {\n                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                            }\n                            fromEl.appendChild(curToNodeChild);\n                            handleNodeAdded(curToNodeChild);\n                        }\n                    }\n\n                    curToNodeChild = toNextSibling;\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                // We have processed all of the \"to nodes\". If curFromNodeChild is\n                // non-null then we still have some from nodes left over that need\n                // to be removed\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n                    if ((curFromNodeKey = callHook(getNodeKey, curFromNodeChild))) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n                    curFromNodeChild = fromNextSibling;\n                }\n            }\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphEl(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        callHook(onNodeDiscarded, fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            callHook(onNodeDiscarded, fromNode);\n        } else {\n            morphEl(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n","import morphAttrs from './morphAttrs';\nimport morphdomFactory from './morphdom';\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;","import { hasAttributeNS } from './util';\n\nexport default function morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrNamespaceURI = attr.namespaceURI;\n\n            if (attrNamespaceURI) {\n                attrName = attr.localName || attrName;\n\n                if (!hasAttributeNS(toNode, attrNamespaceURI, attrName)) {\n                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n                }\n            } else {\n                if (!hasAttributeNS(toNode, null, attrName)) {\n                    fromNode.removeAttribute(attrName);\n                }\n            }\n        }\n    }\n}\n","import DOMElement from \"../dom/dom_element\";\n\nexport default {\n    loadingEls: [],\n    loadingElsByRef: {},\n\n    addLoadingEl(el, value, targetRef, remove) {\n        if (targetRef) {\n            if (this.loadingElsByRef[targetRef]) {\n                this.loadingElsByRef[targetRef].push({el, value, remove})\n            } else {\n                this.loadingElsByRef[targetRef] = [{el, value, remove}]\n            }\n        } else {\n            this.loadingEls.push({el, value, remove})\n        }\n    },\n\n    removeLoadingEl(node) {\n        const el = new DOMElement(node)\n\n        this.loadingEls = this.loadingEls.filter(({el}) => ! el.isSameNode(node))\n\n        if (el.ref in this.loadingElsByRef) {\n            delete this.loadingElsByRef[el.ref]\n        }\n    },\n\n    setLoading(refs) {\n        const refEls = refs.map(ref => this.loadingElsByRef[ref]).filter(el => el).flat()\n\n        const allEls = this.loadingEls.concat(refEls)\n\n        allEls.forEach(el => {\n            if (el.remove) {\n                el.el.classList.remove(el.value)\n            } else {\n                el.el.classList.add(el.value)\n            }\n        })\n\n        return allEls\n    },\n\n    unsetLoading(loadingEls) {\n        loadingEls.forEach(el => {\n            if (el.remove) {\n                el.el.classList.add(el.value)\n            } else {\n                el.el.classList.remove(el.value)\n            }\n        })\n    },\n}\n","import Message from '../message'\nimport { debounce, addMixin, tap, walk } from '../util'\nimport morphdom from '../dom/morphdom'\nimport DOMElement from '../dom/dom_element'\nimport handleLoadingDirectives from './handle_loading_directives'\nimport nodeInitializer from \"../node_initializer\";\nimport store from '../store'\n\nclass Component {\n    constructor(el, connection) {\n        this.id = el.getAttribute('id')\n        this.data = JSON.parse(el.getAttribute('initial-data'))\n        this.events = JSON.parse(el.getAttribute('listening-for'))\n        this.children = JSON.parse(el.getAttribute('children'))\n        this.name = el.getAttribute('name')\n        this.connection = connection\n        this.syncQueue = {}\n        this.actionQueue = []\n        this.messageInTransit = null\n\n        this.initialize()\n    }\n\n    get el() {\n        return DOMElement.getByAttributeAndValue('id', this.id)\n    }\n\n    initialize() {\n        this.walk(el => {\n            // Will run for every node in the component tree (not child nodes)\n            nodeInitializer.initialize(el, this)\n        }, el => {\n            // When new component is encountered in the tree\n            store.addComponent(\n                new Component(el, this.connection)\n            )\n        })\n    }\n\n    addAction(action) {\n        this.actionQueue.push(action)\n\n        // This debounce is here in-case two events fire at the \"same\" time:\n        // For example: if you are listening for a click on element A,\n        // and a \"blur\" on element B. If element B has focus, and then,\n        // you click on element A, the blur event will fire before the \"click\"\n        // event. This debounce captures them both in the actionsQueue and sends\n        // them off at the same time.\n        // Note: currently, it's set to 5ms, that might not be the right amount, we'll see.\n        debounce(this.fireMessage, 5).apply(this)\n    }\n\n    fireMessage() {\n        if (this.messageInTransit) return\n\n        this.messageInTransit = new Message(\n            this,\n            this.actionQueue,\n            this.syncQueue,\n        );\n\n        this.connection.sendMessage(this.messageInTransit)\n\n        this.clearSyncQueue()\n        this.clearActionQueue()\n    }\n\n    queueSyncInput(model, value) {\n        this.syncQueue[model] = value\n    }\n\n    clearSyncQueue() {\n        this.syncQueue = {}\n    }\n\n    clearActionQueue() {\n        this.actionQueue = []\n    }\n\n    receiveMessage(payload) {\n        const response = this.messageInTransit.storeResponse(payload)\n\n        this.data = response.data\n        this.children = response.children\n\n        // This means \"$this->redirect()\" was called in the component. let's just bail and redirect.\n        if (response.redirectTo) {\n            window.location.href = response.redirectTo\n            return\n        }\n\n        this.replaceDom(response.dom, response.dirtyInputs)\n\n        this.handleDirtyInputs(response.dirtyInputs)\n\n        this.unsetLoading(this.messageInTransit.loadingEls)\n\n        this.messageInTransit = null\n\n        if (response.eventQueue && response.eventQueue.length > 0) {\n            response.eventQueue.forEach(event => {\n                store.emit(event.event, ...event.params)\n            })\n        }\n    }\n\n    handleDirtyInputs(dirtyInputs) {\n        // This is manual dirty input hijacking. We just brute-force through\n        // the component nodes, look for the dirty wire:model's and force\n        // a state refresh.\n        this.walk(el => {\n            if (el.directives.missing('model')) return\n            const modelValue = el.directives.get('model').value\n            if (! [].concat(dirtyInputs).includes(modelValue)) return\n\n            el.setInputValueFromModel(this)\n        })\n    }\n\n    replaceDom(rawDom, dirtyInputs) {\n        // Prevent morphdom from moving an input element and it losing it's focus.\n        DOMElement.preserveActiveElement(() => {\n            this.handleMorph(this.addValueAttributesToModelNodes(rawDom.trim()), dirtyInputs)\n        })\n    }\n\n    addValueAttributesToModelNodes(inputDom)\n    {\n        const tempDom = tap(document.createElement('div'), el => { el.innerHTML = inputDom })\n\n        // I need the \"self\" for the later eval().\n        const self = this\n\n        // Go through and add any \"value\" attributes to \"wire:model\" bound input elements,\n        // if they aren't already in the dom.\n        DOMElement.allModelElementsInside(tempDom).forEach(el => {\n            el.setInputValueFromModel(this)\n        })\n\n        return tempDom.innerHTML\n    }\n\n    handleMorph(dom, dirtyInputs) {\n        morphdom(this.el.rawNode(), dom, {\n            childrenOnly: true,\n\n            getNodeKey: node => {\n                // This allows the tracking of elements by the \"key\" attribute, like in VueJs.\n                return node.hasAttribute('key')\n                    ? node.getAttribute('key')\n                    // @todo - remove hard-coded \"wire:\"\n                    : (node.hasAttribute('wire:id') ? node.getAttribute('wire:id') : node.id)\n            },\n\n            onBeforeNodeAdded: node => {\n                return (new DOMElement(node)).transitionElementIn()\n            },\n\n            onBeforeNodeDiscarded: node => {\n                return (new DOMElement(node)).transitionElementOut(nodeDiscarded => {\n                    this.removeLoadingEl(nodeDiscarded)\n                })\n            },\n\n            onBeforeElChildrenUpdated: node => {\n                const el = new DOMElement(node)\n\n                if (el.isComponentRootEl()) return false\n            },\n\n            onBeforeElUpdated: (from, to) => {\n                const fromEl = new DOMElement(from)\n                const toEl = new DOMElement(to)\n\n                if (fromEl.isComponentRootEl()) return false\n\n                toEl.preserveValueAttributeIfNotDirty(fromEl, dirtyInputs)\n            },\n\n            onElUpdated: (node) => {\n                //\n            },\n\n            onNodeDiscarded: node => {\n                // Elements with loading directives are stored, release this\n                // element from storage because it no longer exists on the DOM.\n                this.removeLoadingEl(node)\n            },\n\n            onNodeAdded: (node) => {\n                const el = new DOMElement(node)\n\n                const closestComponentId = el.closestRoot().getAttribute('id')\n\n                if (Number(closestComponentId) === Number(this.id)) {\n                    nodeInitializer.initialize(el, this)\n                } else if (el.isComponentRootEl()) {\n                    store.addComponent(\n                        new Component(el, this.connection)\n                    )\n                }\n\n                // Skip.\n            },\n        });\n    }\n\n    walk(callback, callbackWhenNewComponentIsEncountered = el => {}) {\n        walk(this.el.rawNode(), (node) => {\n            const el = new DOMElement(node)\n\n            // Skip the root component element.\n            if (el.isSameNode(this.el)) return\n\n            // If we encounter a nested component, skip walking that tree.\n            if (el.isComponentRootEl()) {\n                callbackWhenNewComponentIsEncountered(el)\n\n                return false\n            }\n\n            callback(el)\n        })\n    }\n}\n\naddMixin(Component, handleLoadingDirectives)\n\nexport default Component\n","import drivers from './connection/drivers'\nimport Connection from './connection'\nimport store from './store'\nimport Component from \"./component\";\nimport DOMElement from \"./dom/dom_element\";\n\nclass Livewire {\n    constructor({ driver } = { driver: 'http' }) {\n        if (typeof driver !== 'object') {\n            driver = drivers[driver]\n        }\n\n        this.connection = new Connection(driver)\n        this.components = store\n\n        this.start()\n    }\n\n    emit(event, ...params) {\n        this.components.emit(event, ...params)\n    }\n\n    restart() {\n        this.stop()\n        this.start()\n    }\n\n    stop() {\n        this.components.wipeComponents()\n    }\n\n    start() {\n        DOMElement.rootComponentElementsWithNoParents().forEach(el => {\n            this.components.addComponent(\n                new Component(el, this.connection)\n            )\n        })\n    }\n}\n\nif (!window.Livewire) {\n    window.Livewire = Livewire\n}\n\nexport default Livewire\n"],"sourceRoot":""}
